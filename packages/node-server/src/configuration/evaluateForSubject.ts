import type { FlagTypeToValue, PrecomputedFlagMetadata } from '@datadog/flagging-core'
import {
  ErrorCode,
  type EvaluationContext,
  type FlagValueType,
  type Logger,
  type ResolutionDetails,
  StandardResolutionReasons,
} from '@openfeature/server-sdk'
import { matchesRule, type Rule } from '../rules/rules'
import { matchesShard } from '../shards/matchesShard'
import { type Flag, type Split, type VariantType, variantTypeToFlagValueType } from './ufc-v1'

export function evaluateForSubject<T extends FlagValueType>(
  flag: Flag | undefined,
  type: T,
  subjectKey: string,
  subjectAttributes: EvaluationContext,
  defaultValue: FlagTypeToValue<T>,
  logger: Logger
): ResolutionDetails<FlagTypeToValue<T>> {
  if (!flag?.enabled) {
    logger.debug(`returning default assignment because flag is disabled`, {
      flagKey: flag ? flag.key : 'undefined',
      subjectKey,
    })
    return {
      value: defaultValue,
      reason: StandardResolutionReasons.DISABLED,
    }
  }

  const isValid = validateTypeMatch(type, flag.variationType)
  if (!isValid) {
    logger.debug(`variant value type mismatch, returning default value`, {
      flagKey: flag.key,
      subjectKey,
      expectedType: type,
      variantType: flag.variationType,
    })
    return {
      value: defaultValue,
      reason: StandardResolutionReasons.ERROR,
      errorCode: ErrorCode.TYPE_MISMATCH,
    }
  }

  const now = new Date()
  for (const allocation of flag.allocations) {
    if (allocation.startAt && now < new Date(allocation.startAt)) {
      logger.debug(`allocation before start date`, {
        flagKey: flag.key,
        subjectKey,
        allocationKey: allocation.key,
        startAt: allocation.startAt,
      })
      continue
    }

    if (allocation.endAt && now >= new Date(allocation.endAt)) {
      logger.debug(`allocation after end date`, {
        flagKey: flag.key,
        subjectKey,
        allocationKey: allocation.key,
        endAt: allocation.endAt,
      })
      continue
    }

    const matched = containsMatchingRule(allocation.rules, subjectAttributes, logger)
    if (!matched) {
      continue
    }

    const selectedSplit = selectSplitUsingSharding(allocation.splits, subjectKey, flag.key, logger)
    if (selectedSplit) {
      const variant = flag.variations[selectedSplit.variationKey]
      if (variant != null) {
        logger.debug(`evaluated a flag`, {
          flagKey: flag.key,
          subjectKey,
          assignment: variant.value,
        })

        return {
          value: variant.value as FlagTypeToValue<T>,
          reason: StandardResolutionReasons.TARGETING_MATCH,
          variant: variant.key,
          flagMetadata: {
            allocationKey: allocation.key,
            variationType: variantTypeToFlagValueType(flag.variationType),
            doLog: !!allocation.doLog,
          } as PrecomputedFlagMetadata,
        }
      }
    } else {
      logger.debug(`no matching split found for subject`, {
        flagKey: flag.key,
        subjectKey,
        allocationKey: allocation.key,
      })
    }
  }

  // This shouldn't happen since a default allocation is generated by the server
  logger.debug(`returning default assignment because no allocation matched`, {
    flagKey: flag.key,
    subjectKey,
  })

  return {
    value: defaultValue,
    reason: StandardResolutionReasons.DEFAULT,
  }
}

function validateTypeMatch(expectedType: FlagValueType, variantType: VariantType): boolean {
  if (expectedType === 'boolean') {
    return variantType === 'BOOLEAN'
  }
  if (expectedType === 'string') {
    return variantType === 'STRING'
  }
  if (expectedType === 'number') {
    return variantType === 'INTEGER' || variantType === 'NUMERIC'
  }
  if (expectedType === 'object') {
    return variantType === 'JSON'
  }
  throw new Error(`Invalid expected type: ${expectedType}`)
}

export function containsMatchingRule(
  rules: Rule[] | undefined,
  subjectAttributes: EvaluationContext,
  logger: Logger
): boolean {
  if (!rules?.length) {
    return true
  }
  logger.debug(`evaluating rules`, {
    rules: JSON.stringify(rules),
    subjectAttributes,
  })
  return rules.some((rule) => matchesRule(rule, subjectAttributes))
}

function selectSplitUsingSharding(splits: Split[], subjectKey: string, flagKey: string, logger: Logger): Split | null {
  if (!splits || splits.length === 0) {
    return null
  }

  for (const split of splits) {
    logger.debug(`evaluating split sharding`, {
      flagKey,
      subjectKey,
      variationKey: split.variationKey,
      shards: split.shards,
    })

    const matches = split.shards.every((shard) => {
      const shardMatches = matchesShard(shard, subjectKey)
      logger.debug(`shard match result`, {
        flagKey,
        subjectKey,
        variationKey: split.variationKey,
        shard: shard,
        matches: shardMatches,
      })
      return shardMatches
    })

    if (matches) {
      logger.debug(`subject matches split`, {
        flagKey,
        subjectKey,
        variationKey: split.variationKey,
      })
      return split
    }
  }

  logger.debug(`subject matches no splits`, {
    flagKey,
    subjectKey,
  })

  return null
}
